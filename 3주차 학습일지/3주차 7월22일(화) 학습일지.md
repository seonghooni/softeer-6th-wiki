# 1. 리뷰
## :laughing: 오늘 한 작업
### 1. 개발 과제 수행

#### POST 이미지 업로드 기능 구현

어제 팀원들과 진행한 회고에서 이야기를 나누다가 문제 원인을 발견했다.

혼자 고민할 때는 발견하지 못하더니..  
팀원 한 분이 "저는 String으로 body를 입력받았었는데 그것부터 고치려니 머리 아파요." 라고 말씀하시자마자

### "어?!"
라는 생각이 들었다.

Request를 파싱할 때 나도 팀원과 똑같이  
body를 BufferedReader로 char[ ] 로 받고, 이를 byte[ ]로 변환하고 있었다..

이걸 깨닫자마자 문제는 쉽게 풀 수 있었다.

<br>

### 2. 종합 프로젝트 회의

오늘 회의에서는  
기획 파트에서 작성한 **와이어프레임**,  
디자인 파트에서 준비한 **디자인 초안 및 요소별 의미**를 공유받았다.

각 파트의 지식과 경험을 바탕으로  
**활발한 논의**가 이루어졌고,  
기능 구현 관점에서 유의미한 진전도 있었다.

예를 들어,  
기획팀에서는
> **"동행자와 노인이 만나기 30분 전부터 서로의 위치를 공유할 수 있으면 좋겠다."**  

라는 아이디어를 제안해주셨고,

이에 대해 백엔드 측에서는 다음과 같은 의견을 제시했다:
- 모바일 웹 환경에서는 **브라우저가 종료되면 실시간 위치 공유가 중단될 수 있다**
- 특히 **노인 사용자들이 브라우저를 계속 켜두기는 어렵다**

이러한 현실적인 제약 사항을 바탕으로
> **'실시간 위치 공유' 대신  
> '몇 분 전 마지막 위치'를 기반으로 공유하는 방식으로 방향을 조정**

결과적으로 기능 기획의 **현실성과 완성도**를 함께 높일 수 있었다.

<br>

## :dizzy: 작업 과정에서의 배운 것

### 🔹 머리가 안 돌아갈 땐 너무 혼자 해결하려고 하지 말자.

혼자서 고민하다보니, 잘못된 길로 빠질 때도 있고 오히려 더 문제 해결에 악영향을 미칠 때가 있는 것 같다.

댕글님 말씀대로, 도저히 안되면 환기를 시키고 와야하는 것 같다.

혼자 오래 붙들고 있는 것만이 정답이 아니다.

문제 원인을 파악하지 못하고 엉뚱한 코드만 고치면서 헤매던 것을,  
팀원들과 20분정도 이야기를 주고 받으니 문제 원인을 파악해 버렸다.

<br>

### 🔹 처음에는 막막했던 팀 프로젝트가 조금씩 방향이 보인다.

첫 주차에는 **주제 선정 자체가 가장 어려운 문제**였다.  
우리가 정말 이 문제를 해결할 수 있을까?  
이미 더 나은 서비스가 존재하지는 않을까?

> **그동안은 '왜 안되는가'에만 집중하고 있었던 것 같다.**

하지만 프로젝트 주제를 정하고  
솔루션을 점점 구체화해 나가면서,  
관련 자료도 더 적극적으로 찾아보게 되었고,

그 과정에서 **우리가 할 수 있는 것과 없는 것**이  
조금씩 명확하게 구분되기 시작했다.

아직까지는
> '우리가 어떤 영역에 도전할 것인가?' 에 대해 완전히 뚜렷하지는 않지만,

적어도 지금은  
**막연함이 아닌 '윤곽'을 보며 움직이고 있다는 점**에서  
한 걸음 나아간 것 같다.


<br>


## :sob: 어려웠던 점

### 이미지 불러오는 기능 구현 과정

성공적으로 이미지 파일을 업로드하긴 하였으나,  
브라우저에서 불러오는 기능이 원활하게 동작하지 않았다.

경로는 정확하게 준 것 같은데, 파일명이 인코딩이 제대로 되지 않았던 걸까.

오늘은 가용한 시간이 많지 않았기 때문에, 내일은 웹 서버 요구사항을 조금씩 해결해 나갈 생각이다.


<br><br>

# 2. 회고 (KPT)

✅ **K – Keep (유지할 것)**

- 팀원들과 긍정적으로 이야기 나누기
- 팀원들과 적극적으로 소통하기
- 잘 안풀리면 가끔씩 다른 활동으로 환기시켜보기


🛠️ **P – Problem (개선이 필요한 점)**

- 오늘도 코드 리뷰에서, "이건 왜 쓰신거에요?" 라는 질문에 대답을 못했던 순간이 있었다.  
매번 개선하자고는 하는데, 쉽게 고쳐지지는 않는다.

🔄 **T – Try (시도할 것)**

- 특정 클래스에 책임이 몰빵되어있다. 반드시 리팩토링할 것. (나중에 더 힘들어지기 전에)

<br><br>

# 3. 학습 내용

## 📌 JVM — Write Once, Run Anywhere

JVM(Java Virtual Machine)은 **한 번 작성한 코드를 OS에 관계없이 실행**할 수 있게 하는 가상 머신이다.  
"**Write Once, Run Anywhere**"라는 철학을 실현하는 핵심 기술이다.

## 📌 ClassLoader 의 특징 = 동적 로딩

JVM은 `.class` 파일을 **필요할 때 한 번만** 로딩한다.  
이로써 유연성과 성능을 높인다.

### 🔹 로딩 → 링킹 → 초기화 (Initialization)

- **로딩(Loading)**: `.class` 파일을 메서드 영역에 올림
- **링킹(Linking)**:
    - **검증**: 유효한 클래스인지 확인
    - **준비**: static 변수 메모리 할당
    - **해결**: 심볼 → 실제 참조로 변경
- **초기화(Initialization)**: static 변수에 값 할당, static 블록 실행

---

## 📌 Execution Engine — 바이트코드를 실제로 실행

### 1. Interpreter
- 바이트코드를 한 줄씩 해석하고 실행
- 기계어로 바꾸는 것이 아닌, 바이트코드를 해석하고 실행합니다.

### 2. JIT Compiler (Just-In-Time)
- 핫스팟 코드(자주 실행되는 코드)를 네이티브 코드로 컴파일
- 자주 사용되는 바이트코드에 대해, 기계어로 캐시해 둔다.

---

## 📌 Garbage Collector — 자동 메모리 관리

### 🔸 기본 구조
- **Stop-the-World**: GC 시 모든 쓰레드 정지
- **Mark and Sweep**: 생존 여부 판단 → 불필요한 객체 제거

### 🔸 Young & Old Generation

#### Young Generation
- 객체 대부분이 생성됨 (Eden)
- **Minor GC**가 자주 발생
- Eden → Survivor0 → Survivor1 로 생존 객체 이동

#### Old Generation
- 오래된 객체가 이동
- **Major GC**가 비교적 드물게 발생하지만, 성능 비용이 큼

---

## 📌 Runtime Data Area — JVM 메모리 구조

| 영역 | 설명                                             |
|------|------------------------------------------------|
| **Method Area** | 클래스 정보, 메서드 정보, static 변수, 상수 등 저장. GC 대상이기도 함 |
| **Heap** | `new`로 생성된 객체 및 배열 저장. **GC 대상**               |
| **Stack** | 스레드별로 할당. 메서드 호출 시 스택 프레임 생성. **Thread-safe**  |
| **PC Register** | 각 스레드의 다음 실행 명령 위치 저장                          |
| **Native Method Stack** | C/C++ 네이티브 메서드 실행 시 사용됨                        |

## 📌 Thread-safe하기 위해 스택에 저장한다? ❌
### 스레드마다 독립된 스택이 있기 때문에 Thread-safe하다 ⭕
아래는 스택에 저장되지 않고 힙에 저장된다. 다만, 동기화 매커니즘에 의해 안전한 것일 뿐
- Atomic
- Synchronized
- Thread local