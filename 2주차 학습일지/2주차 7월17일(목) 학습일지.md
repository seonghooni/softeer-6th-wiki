# 1. 리뷰
## :laughing: 오늘 한 작업
### 1. 개발 과제 수행

오늘은 진도를 좀 나가긴 했다.

요약하면 다음과 같다. 또한, 그렇게 적용한 이유를 한 번 적어보고자 한다.

<u> (그동안은 했던 일만 기록했다면, 이제부터는 그렇게 했던 이유도 함께 적어볼 것이다.</u> <br><br>

#### Cookie를 통한 로그인 및 로그아웃 세션 관리 (RequestCookie, ResponseCookie를 굳이 분리했다.) 

클라이언트에서 보내는 쿠키와, 서버에서 보내는 쿠키는 Header도 명확히 다르고, 사용하는 방법도 다르다.

    - 클라이언트는 `Cookie` 헤더를 사용하며, 브라우저단에서 "유효하다"고 생각하는 모든 쿠키 값을 `key=value; key2=value2` 형식처럼 한번에 보낸다.
    - 서버는 `Set-Cookie` 헤더를 사용하며, 클라이언트에게 저장하라고 명령하는 쿠키를 개별적으로 전송한다. 이때는 `Path=/; HttpOnly; Max-Age=3600` 처럼 속성도 함께 포함한다.

즉, 요청 쿠키는 파싱하여 값을 읽는 역할, 응답 쿠키는 새로운 쿠키를 생성하고 속성을 설정하는 역할로 분명히 나뉘기 때문에, RequestCookie, ResponseCookie 클래스를 분리하여 책임을 명확히 하는 것이 타당하다.

이처럼 구조적으로 분리함으로써, 유지보수 시 파싱 로직과 생성 로직을 독립적으로 다룰 수 있으며, 보안 옵션 추가나 쿠키 속성 변경 시에도 코드 응집도를 높이고 오류 가능성을 줄일 수 있다.

<br>

#### html을 동적으로 반환하기 위해 HtmlTemplateRendere, TemplatePage 작성

내가 작성한 각각의 클래스는 다음과 같은 역할을 가지도록 했다.

- HtmlTemplateRenderer는 html 파일(index.html)을 읽고, 그 안에 있는 {{name}}, {{value}} 같은 동적 변수 자리를 실제 데이터로 바꿔주는 역할

- TemplatePage는 이 렌더링 과정에 필요한 템플릿 경로, 데이터(Map) 같은 정보를 담고 있는 전달 객체(DTO 역할)

- 즉, HtmlTemplateRenderer는 TemplatePage와 User 정보를 참고하여 html의 변수를 동적으로 replace한다.


다음은 정적 리소스를 처리하는 StaticResourceHandler에 적용한 코드인데, 나는 `이 부분을 AOP를 적용하면 유지보수하기 수월하지 않을까?` 라는 생각에 이와 같이 작성하였다.

```java
/*
 * StaticResourceHandler.process() 의 일부분
 * */
        ...
        
        // 동적 템플릿인지 확인
        // 동적 템플릿인 경우, 유저 정보가 유효할 경우 동적으로 응답 변경
        Optional<TemplatePage> maybeTemplate = TemplatePage.match(path);

        if (maybeTemplate.isPresent()) {
            Map<String, String> vars = maybeTemplate.get().buildVariables(user);

            String renderedHtml = HtmlTemplateRenderer.render(file.getPath(), vars);

            responseBuilder.responseBody(response, renderedHtml.getBytes(StandardCharsets.UTF_8));
            return response;
        }


        return response;
    }
```

<br>

#### ApiController 메서드들을 @애노테이션 기반으로 스캔하고, HttpRequestRouter에 등록하는 로직 작성하기

나는 특히, 이 라우팅 과정을 2주동 안 여러 버전으로 업데이트를 해 나갔다.

오늘 했던 작업이 아마 라우팅에 관해서는 최종 작업이라고 생각하고, 실제로 스프링이 리플렉션을 통해 애플리케이션 실행 시점에 컨트롤러를 조회하는 것을 간단하게 구현하였다. (김동성님의 코드 리뷰에서 영감을 받았다.)

`컨트롤러 라우팅을 어떻게 발전시켜 나갔는지`에 대해서는 이번 주말에 따로 글을 작성해보고자 한다. (김수환님에게 영감을 받았다.)

코드가 꽤 길기 때문에, 다른 포스팅에서 작성하는 것으로 하고, 여기서는 간단하게 넘어가곘다.

<br>

## :dizzy: 작업 과정에서의 배운 것

### Tomcat이나 Spring과 조금씩 닮아간다.

점차 코드의 유지보수성을 신경쓰고 가독성을 높이기 위한 작업을 하다보니, 결과물이 Tomcat과 Spring 그 어딘가에 부분적으로 닮는 것 같다.

잘 하고 있는 것이라고 생각하겠다.

<br>

### 최재현님의 학습일지를 보며..

오늘 아침에 댕글님께서 좋았다고 느끼셨던 학습일지를 언급해주셨다. 나의 자랑스러운 팀원이신 최재현님의 학습일지였다.

읽으면서 반성하게 된 점이 있었다.

나의 그동안 학습 회고는 `사실에 대한 나열` 이 큰 비중을 차지했다고 느꼈다.

재현님의 학습일지에서는, 단순히 자신이 무엇을 했는지에 그치지 않고, `자신이 가졌던 느낌과 생각`에 대해 구체적으로 서술되어 있었다.

<br>

###  단순한 지식 정리 < 사실에 대한 나열 < 자신이 가졌던 느낌과 생각 

단순한 지식 정리는 금세 잊힌다.
사실에 대한 나열은 기록으로 남지만, 오래 기억되진 않는다.

내가 왜 그렇게 생각했고, 어떤 것을 느꼈는지를 적어야

어떻게 변할지 알 수 있고, 나중에 내가 다시 봤을 때 얼마나 성장했는지 알 수 있겠다고 생각했다.


최소한 오늘처럼, 어떤 작업을 했는지 적었다면 **왜 그렇게 생각했는지**를 함께 기록하겠다.

<br>


## :sob: 어려웠던 점

### 동적 템플릿 작성 과정

아직도 내가 구현한 방법이 효율적인지?는 잘 모르겠다.

지금의 코드 레벨에서는 동적으로 값을 변경해야할 변수가 많아진다면 유지보수성과 성능에서 많이 비효율적일 수 있겠다는 생각을 한다.

하지만 이또한, 내가 `HttpRequest 라우팅 과정을 업데이트 `했던 것처럼,

다른 팀원 분들의 코드 리뷰와 피드백을 진행하다보면 개선될 것이라고 생각한다.



<br><br>

# 2. 회고 (KPT)

✅ **K – Keep (유지할 것)**

- 팀원들과 데일리 스크럼, 코드 리뷰 등 의견과 피드백을 열심히 주고 받는 것
- 또한, 그 과정에서 본받아야 할 점을 캐치하고, 내 코드에 적용하는 것
- 어떤 근거를 바탕으로 결론을 도출했는지 항상 생각할 것


🛠️ **P – Problem (개선이 필요한 점)**

- 고민하는 과정이 너무나 길다. 우선 부딪혀보고 리팩토링을 해 나갈 것. 처음부터 너무 잘하려고 하지 말 것

🔄 **T – Try (시도할 것)**

- Http 동적 응답을 어떻게 구현했는지, 다른 팀원들은 왜 그렇게 생각했는 지를 물어볼 것 (의도 파악할 것)
- 나와는 무엇으로 인해 다르게 생각했는지도 고민해볼 것

<br><br>

# 3. 학습 내용

## 📌 애노테이션 기반 핸들러 등록 방식의 장단점


| 구분       | 장점                                                                 | 단점                                                                 |
|------------|----------------------------------------------------------------------|----------------------------------------------------------------------|
| **자동화**   | 핸들러 등록이 자동화되어 생산성이 높아짐                                        | 구현 복잡도 증가, 학습 비용 발생                                                  |
| **유지보수성** | 애노테이션만으로 라우팅 정의 가능 → 가독성 및 유지보수 용이                         | 내부 동작이 추상화되어 디버깅이 어려움                                              |
| **확장성**   | 새로운 컨트롤러 추가 시 최소 변경 → 확장에 유리                                    | 잘못된 애노테이션 사용 시 런타임 오류 발생 가능                                      |
| **일관성**   | 선언적 방식으로 코드 구조를 통일할 수 있음                                       | 클래스 탐색 시 ClassLoader 의존, 성능 이슈 발생 가능성                              |
| **재사용성** | 공통 처리(로깅, 인증 등)를 애노테이션 기반으로 쉽게 적용 가능                         | 리플렉션은 타입 안정성이 낮고, 컴파일 타임 검증이 어려움                             |
