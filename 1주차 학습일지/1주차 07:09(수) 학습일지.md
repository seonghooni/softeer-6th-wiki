# 2025년 7월 9일 (수) 학습일지


**목차**

- [1. 커피샵으로 도메인을 작성해보기](#1-커피샵으로-도메인을-작성해보기)
- [2. 개발 과제 - 웹 서버 구현 1주차--1번 과제](#2-개발-과제---웹-서버-구현-1주차--1번-과제)
- [3. 데일리 스크럼과 코드 리뷰](#3-데일리-스크럼과-코드-리뷰)
- [4. 내일의 목표](#4-내일의-목표)

---

## 1. 커피샵으로 도메인을 작성해보기

#### 🔹 1번 과정)

짧은 시간 안에, '카페 주방'에서 벌어지는 일에 대해 **도메인을 파악하고, 공통점과 차이점에 대해서 파악**해보았다.

우리 조(1조)는 큰 프로세스를 다음과 같이 4가지 과정으로 나누어 보았다. 

**(`응대 - 제조 - 뒷정리 - 재고 보충`)**

나는 '제조' 단계를 구체적으로 다루었다.

크게 **카페인/디카페인 음료**를 나눴고, **각 음료별로 들어가는 재료를 분석**하여 도식화 하였다. (ICE or HOT / 물 or 우유 등)


#### 🔹 2번 과정)

 분석하고 구성한 자료를 바탕으로 다른 조들과 공유하며, 의견을 공유하는 과정을 진행했다.

- 나는 카페인 여부 -> 물/우유 -> 기타 재료 순서로 분류를 하였지만,
- 어떤 조는 재료를 우선 모두 나열한 다음 도메인을 파악하려고 하였고,
- 또 어떤 조는 과정을 중심으로 도메인에 대해 파악하였다.

서로가 놓쳤던 부분이나, 서로 다른 부분에 대해 어떻게 접근했는지 의견을 공유하는 시간을 가졌다.

<br><br>

### 💬 느낀점

<u>도메인 모델링은 정답이 있는 작업이 아니라, 해석과 관점의 차이에 따라 다양하게 도출될 수 있다는 점을 체감했다. </u>

**공유**하는 과정을 통해 **내가 미처 생각하지 못했던 요소를 새롭게 발견**했고,

여러 사람의 시선으로 도메인을 분석하는 것이 **훨씬 풍부한 인사이트를 제공한다는 것**을 배웠다.


---
## 2. 개발 과제 - 웹 서버 구현 (1주차 / 1번 과제)

#### 🔹 유지보수하기 좋은 코드 작성하기

기존 `RequestHandler.run()` 함수에 있는 일련의 코드를 유지보수하기 쉽도록 하기 위해 다음과 같은 과정을 진행했다.

- HttpRequest 클래스를 만들어, method, path, headers 필드를 생성하였다.
- 파싱, 라우팅 매핑, 입출력 처리 등 로직을 각 역할별로 함수화하여 가독성을 개선했다.

#### 🔹 concurrent 패키지 학습하기
웹 통신 과정에서 기존 Thread 클래스를 생성하고 실행하는 과정에서 다음과 같은 단점이 있음을 학습했다.
- 쓰레드의 개수에 대해 관리하기 어렵다. (서버의 리소스를 효과적으로 제어하기 어렵다. )
- 요청마다 쓰레드를 생성/소멸 과정을 통해 오버헤드가 발생한다.

따라서 쓰레드풀을 활용하여 고정된 수의 쓰레드를 재사용하는 구조를 적용하고자 했다.  

이때, Java에서 제공하는 concurrent 패키지의 **ExecutorService 클래스에서 고정 쓰레드풀을 활용할 수 있다는 점**을 파악했고, 이를 적용하였다.

동시에, 비록 현재 기능에서는 사용하지 않지만 **ExecutorService의 shutdown()과 shutdownNow()의 차이점에 대해 궁금해서 알아보았다.**
- shutdown()은 현재까지 할당한 모든 작업이 완료될 때까지 기다리고, shutdownNow()는 모든 작업에 대해 interrupt()를 호출하여 종료한다. 
  
  
<br><br>

### 💬 느낀점

스프링에서 제공하는 Tomcat을 당연하게 사용해왔기에, 클라이언트 요청에 대한 웹서버의 처리에 대해서 깊게 고민을 해보지 않았다는 점을 반성했다.

우리가 이번 과제에서 구현한 내용은 Spring의 DispatherServlet + RequestMapping의 과정일 것이다.

또한, Thread를 직접 생성하던 방식에서 ExecutorService를 통한 스레드풀 구조로 전환하면서
서버의 자원을 어떻게 효율적으로 관리할 수 있는지 실감할 수 있었다.

이번 리팩토링과 코드 구현을 바탕으로,
Spring의 DispatherServlet + RequestMapping의 처리 과정에 대한 지식을 다져나가고자 한다.

---- 
## 데일리 스크럼(10 :00)과 코드 리뷰(14 :00)

데일리 스크럼 시간에는 우리 그룹(1조) 팀원들과 함께 각자 오늘 목표에 대해서 공유했으며

코드 리뷰에서는 각자가 구현한 부분에 대해서 설명하고, 피드백 받는 과정을 진행했다.
  
  

<br><br>

### 💬 느낀점

**특히 나는 이 과정이 가장 유의미했다고 생각한다.**
- 나는 코드의 가독성과 유지보수의 측면에서 고민한 것에 대해서 공유했고,
- 다른 누군가는 BufferedReader나 Socket과 같은 리소스 관리에 대해 적용한 것을 공유해주셨다.
- 또 누군가는 이 리소스를 할당하고 해제하는 과정에서 keep-alive 헤더의 동작 방식과 (age, timeout)의 차이점에 대해 리서치한 내용을 공유해주셨다.

이런 공유 과정을 통해, 내가 놓쳤던 생각이나 문법에 대해 다시 한 번 생각해 볼 수 있었고,
특히 keep-alive와 리소스 할당에 대한 이야기를 나누고 나니, 

> "만약 클라이언트에게 keep-alive 헤더를 포함한 요청이 왔고, 이를 승인하고자 한다면 소켓에 대해서는 리소스를 해제하면 안될텐데, 현재 코드 구조에서 이를 클린하게 작성할 수 있는 방법이 무엇일까?"

라는 생각이 들었다.

다른 요구사항을 적용하고, 관련 내용을 학습하다 보니 위 고민에 대한 실마리를 해결하진 못했지만, 반드시 한 번 코드를 개선해볼 것이다.

---

## 내일의 목표
1. 1주차 과제의 모든 요구사항을 구현해보는 것이 목표이다.

2. 그렇지 못하더라도, 최소한 2번 과제를 마무리하고, Response 클래스를 생성하여 유지보수와 가독성이 좋은 코드로 개선해보고자 한다.
3. 요청마다 매번 socket 리소스를 반환해줬음에도 불구하고, 매 요청마다 port번호가 증가하는 것을 확인했는데, 그 이유를 내일 데일리 스크럼 혹은 코드 리뷰 시간에 그룹원들과 공유하고자 한다.